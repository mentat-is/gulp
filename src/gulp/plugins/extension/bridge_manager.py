"""
Bridge Manager Extension Plugin

Manages external bridge applications which perform realtime ingestion into Gulp.

APIs exposed:
- /register_bridge (POST): register a bridge (called by bridge). Requires Gulp token with INGEST permission.
- /unregister_bridge (DELETE): unregister a bridge. Requires INGEST permission.
- /create_start_ingestion (POST): create and request bridge to start ingestion. Requires INGEST permission.
- /stop_ingestion (POST): stop a running ingestion. Requires INGEST permission.
- /delete_ingestion (DELETE): stop and delete a bridge ingestion task. Requires INGEST permission.
- /list_ingestion_tasks (POST): list bridge tasks (filter). Requires INGEST permission.
- /list_bridges (POST): list bridges (filter). Requires INGEST permission.
- /set_bridge_task_status (POST): bridge reports failure for a task. Requires INGEST permission.

The plugin stores a `bridge_token` provided by the bridge at registration time and will
use it when calling back to the bridge (Authorization: Bearer <bridge_token>).
"""

import json
from typing import Annotated, Literal, Optional, override

import aiohttp
import muty.crypto
from fastapi import Body, Depends, Query
from fastapi.responses import JSONResponse
from muty.jsend import JSendException, JSendResponse
from muty.log import MutyLogger
from muty.pydantic import autogenerate_model_example_by_class
from sqlalchemy import ForeignKey, String
from sqlalchemy.dialects.postgresql import JSONB
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.ext.mutable import MutableDict
from sqlalchemy.orm import Mapped, mapped_column, relationship

from gulp.api.collab.operation import GulpOperation
from gulp.api.collab.structs import (
    GulpCollabBase,
    GulpCollabFilter,
    GulpRequestStatus,
    GulpUserPermission,
)
from gulp.api.collab.user_session import GulpUserSession
from gulp.api.collab_api import GulpCollab
from gulp.api.server.server_utils import ServerUtils
from gulp.api.server.structs import APIDependencies
from gulp.api.server_api import GulpServer
from gulp.config import GulpConfig
from gulp.plugin import GulpPluginBase, GulpPluginType
from gulp.structs import GulpPluginParameters, ObjectAlreadyExists

COLLABTYPE_BRIDGES = "bridges"
COLLABTYPE_BRIDGES_TASK = "bridges_task"


class Plugin(GulpPluginBase):
    """Bridge manager plugin"""

    _bridge_timeout_sec: int = 30

    class GulpBridgeEntry(GulpCollabBase, type=COLLABTYPE_BRIDGES):
        __table_args__ = {"extend_existing": True}

        url: Mapped[str] = mapped_column(
            String, doc="the bridge url in the format proto://[user:password]host:port"
        )
        bridge_token: Mapped[str] = mapped_column(
            String, doc="the token generated by the bridge when registering, then used to call its other API"
        )
        status: Mapped[Optional[str]] = mapped_column(
            String, doc='"ready", "offline"', default="offline"
        )
        tasks: Mapped[Optional[list["Plugin.GulpBridgeTaskEntry"]]] = relationship(
                "GulpBridgeTaskEntry",
                cascade="all, delete-orphan",
                uselist=True,
                lazy="selectin",
                doc="The tasks associated with this bridge.",
                default_factory=list,
            )

        @classmethod
        def example(cls) -> dict:  # type: ignore[override]
            d = super().example()
            d.update(
                {
                    "name": "my_bridge",
                    "url": "http://127.0.0.1:8888",
                    "token": "bridge_token_value",
                    "status": "ready",
                }
            )
            return d

    class GulpBridgeTaskEntry(GulpCollabBase, type=COLLABTYPE_BRIDGES_TASK):
        __table_args__ = {"extend_existing": True}

        bridge_id: Mapped[str] = mapped_column(ForeignKey("bridges.id", ondelete="CASCADE"), doc="id of the bridge this task belongs to")
        plugin_params: Mapped[dict] = mapped_column(MutableDict.as_mutable(JSONB), doc="task specific parameters, passed via GulpPluginParameters structure")
        status: Mapped[Optional[str]] = mapped_column(String, doc="ongoing|failed|done", default=None)
        error: Mapped[Optional[str]] = mapped_column(String, doc="error message if failed", default=None)

        @classmethod
        def example(cls) -> dict:  # type: ignore[override]
            d = super().example()
            d.update(
                {
                    "bridge_id": "bridge_id",
                    "plugin_params": autogenerate_model_example_by_class(
                        GulpPluginParameters
                    ),
                    "status": "ongoing",
                }
            )
            return d
    
    @override
    def desc(self) -> str:
        return "manages external bridges and their realtime ingestion tasks."

    def type(self) -> GulpPluginType:
        return GulpPluginType.EXTENSION

    def display_name(self) -> str:
        return "Bridge Manager"

    @override
    def tables(self) -> list[str]:
        return [COLLABTYPE_BRIDGES, COLLABTYPE_BRIDGES_TASK]

    async def post_init(self, **kwargs):
        if self.is_running_in_main_process():
            MutyLogger.get_instance().debug("adding api routes for bridge_manager plugin ...")

            # read configuration
            cfg = GulpConfig.get_instance().get("bridge_manager", {})
            self._bridge_timeout_sec = int(cfg.get("bridge_timeout_sec", 30))

            # register API routes
            GulpServer.get_instance().add_api_route(
                "/register_bridge",
                self.register_bridge_handler,
                methods=["POST"],
                tags=["bridge"],
                response_model=JSendResponse,
                response_model_exclude_none=True,
                summary="register a bridge with gulp.",
                description="Called by a bridge to register with gulp. Requires a valid gulp token with INGEST permission.",
                responses={
                    200: {
                        "content": {
                            "application/json": {
                                "example": {
                                    "status": "success",
                                    "timestamp_msec": 1701278479259,
                                    "req_id": "903546ff-c01e-4875-a585-d7fa34a0d237",
                                    "data": {"bridge_id": "bridge_id"},
                                }
                            }
                        }
                    }
                },
            )

            GulpServer.get_instance().add_api_route(
                "/unregister_bridge",
                self.unregister_bridge_handler,
                methods=["DELETE"],
                tags=["bridge"],
                response_model=JSendResponse,
                response_model_exclude_none=True,
                summary="unregister a bridge.",
                description="Called by a bridge to unregister with gulp. Requires a valid gulp token with INGEST permission.",
                responses={
                    200: {
                        "content": {
                            "application/json": {
                                "example": {
                                    "status": "success",
                                    "timestamp_msec": 1701278479259,
                                    "req_id": "903546ff-c01e-4875-a585-d7fa34a0d237",
                                    "data": {
                                        "bridge_id": "bridge_id"
                                    },
                                }
                            }
                        }
                    }
                },
            )

            GulpServer.get_instance().add_api_route(
                "/create_start_ingestion",
                self.create_start_ingestion_handler,
                methods=["POST"],
                tags=["bridge"],
                response_model=JSendResponse,
                response_model_exclude_none=True,
                summary="creates a bridge ingestion task and start it.",
                description="Creates or retrieves a bridges_task and calls bridge `start_ingestion` endpoint to start ingestion.",
                responses={
                    200: {
                        "content": {
                            "application/json": {
                                "example": {
                                    "status": "success",
                                    "timestamp_msec": 1701278479259,
                                    "req_id": "903546ff-c01e-4875-a585-d7fa34a0d237",
                                    "data": {"bridge_task_id": "bridge_task_id"},
                                }
                            }
                        }
                    }
                },
            )

            GulpServer.get_instance().add_api_route(
                "/stop_ingestion",
                self.stop_ingestion_handler,
                methods=["POST"],
                tags=["bridge"],
                response_model=JSendResponse,
                response_model_exclude_none=True,
                summary="stop a bridge ingestion task.",
                description="Stops a running bridge ingestion task by calling bridge `stop_ingestion` endpoint.",
                responses={
                    200: {
                        "content": {
                            "application/json": {
                                "example": {
                                    "status": "success",
                                    "timestamp_msec": 1701278479259,
                                    "req_id": "903546ff-c01e-4875-a585-d7fa34a0d237",
                                    "data": {
                                        "bridge_task_id": "bridge_task_id"
                                    },
                                }
                            }
                        }
                    }
                },
            )

            GulpServer.get_instance().add_api_route(
                "/delete_ingestion",
                self.delete_ingestion_handler,
                methods=["DELETE"],
                tags=["bridge"],
                response_model=JSendResponse,
                response_model_exclude_none=True,
                summary="delete a bridge ingestion task.",
                description="Calls bridge `stop_ingestion` endpoint to stop an ingestion task and delete it from gulp collab database",
                responses={
                    200: {
                        "content": {
                            "application/json": {
                                "example": {
                                    "status": "success",
                                    "timestamp_msec": 1701278479259,
                                    "req_id": "903546ff-c01e-4875-a585-d7fa34a0d237",
                                    "data": {},
                                }
                            }
                        }
                    }
                },
            )

            GulpServer.get_instance().add_api_route(
                "/list_ingestion_tasks",
                self.list_ingestion_tasks_handler,
                methods=["POST"],
                tags=["bridge"],
                response_model=JSendResponse,
                response_model_exclude_none=True,
                summary="list bridge ingestion tasks on gulp's collab database.",
                responses={
                    200: {
                        "content": {
                            "application/json": {
                                "example": {
                                    "status": "success",
                                    "timestamp_msec": 1701278479259,
                                    "req_id": "903546ff-c01e-4875-a585-d7fa34a0d237",
                                    "data": [Plugin.GulpBridgeTaskEntry.example()],
                                }
                            }
                        }
                    }
                },
            )

            GulpServer.get_instance().add_api_route(
                "/list_bridges",
                self.list_bridges_handler,
                methods=["POST"],
                tags=["bridge"],
                response_model=JSendResponse,
                response_model_exclude_none=True,
                summary="list registered bridges on gulp's collab database.",
                responses={
                    200: {
                        "content": {
                            "application/json": {
                                "example": {
                                    "status": "success",
                                    "timestamp_msec": 1701278479259,
                                    "req_id": "903546ff-c01e-4875-a585-d7fa34a0d237",
                                    "data": [Plugin.GulpBridgeEntry.example()],
                                }
                            }
                        }
                    }
                },
            )

            GulpServer.get_instance().add_api_route(
                "/set_bridge_task_status",
                self.set_bridge_task_status_handler,
                methods=["POST"],
                tags=["bridge"],
                response_model=JSendResponse,
                response_model_exclude_none=True,
                summary="may be called by a bridge to set status of a bridge ingestion task on gulp collab's database",
                responses={
                    200: {
                        "content": {
                            "application/json": {
                                "example": {
                                    "status": "success",
                                    "timestamp_msec": 1701278479259,
                                    "req_id": "903546ff-c01e-4875-a585-d7fa34a0d237",
                                    "data": {
                                        "bridge_task_id": "bridge_task_id"
                                    },
                                }
                            }
                        }
                    }
                },
            )

            MutyLogger.get_instance().debug("creating bridges_manager tables ...")
            await GulpCollab.get_instance().create_table(Plugin.GulpBridgeEntry.__table__)
            await GulpCollab.get_instance().create_table(Plugin.GulpBridgeTaskEntry.__table__)
        else:
            MutyLogger.get_instance().debug("bridge_manager initialized in worker process")

    async def register_bridge_handler(
        self,
        token: Annotated[str, Depends(APIDependencies.param_token)],
        name: Annotated[str, Query(description="bridge name")],
        url: Annotated[str, Query(description="bridge url in the format proto://[user:password]host:port")],
        bridge_token: Annotated[str, Query(description="unique token generated by the bridge (will be stored by gulp to call other bridge APIs)")],
        req_id: Annotated[str, Depends(APIDependencies.ensure_req_id_optional)] = None,
    ) -> JSONResponse:
        params = locals()
        params.pop("self")
        ServerUtils.dump_params(params)

        try:
            async with GulpCollab.get_instance().session() as sess:
                s = await GulpUserSession.check_token(sess, token, permission=GulpUserPermission.INGEST)
                bridge_id: str = muty.crypto.hash_sha1(f"{name}{url}")
                bridge = await Plugin.GulpBridgeEntry.create_internal(
                    sess,
                    s.user.id,
                    name=name,
                    url=url,
                    obj_id=bridge_id,
                    bridge_token=bridge_token,
                    status="ready",
                )

            return JSONResponse(JSendResponse.success(req_id=req_id, data={"bridge_id": bridge.id}))
        except Exception as ex:
            raise JSendException(req_id=req_id) from ex

    async def unregister_bridge_handler(
        self,
        token: Annotated[str, Depends(APIDependencies.param_token)],
        bridge_id: Annotated[str, Query(description="id of the bridge to unregister")],
        req_id: Annotated[str, Depends(APIDependencies.ensure_req_id_optional)] = None,
    ) -> JSONResponse:
        params = locals()
        params.pop("self")
        ServerUtils.dump_params(params)

        try:
            async with GulpCollab.get_instance().session() as sess:
                bridge: Plugin.GulpBridgeEntry
                s, bridge, _ = await Plugin.GulpBridgeEntry.get_by_id_wrapper(sess, token, bridge_id, permission=GulpUserPermission.INGEST)
                await bridge.delete(sess, user_id=s.user.id, req_id=req_id)

            return JSONResponse(JSendResponse.success(req_id=req_id, data={"bridge_id": bridge.id}))
        except Exception as ex:
            raise JSendException(req_id=req_id) from ex

    async def create_start_ingestion_handler(
        self,
        token: Annotated[str, Depends(APIDependencies.param_token)],
        bridge_id: Annotated[str, Query(description="id of the bridge to use for ingestion")],
        operation_id: Annotated[str, Query(description="operation id to ingest into")],
        plugin_params: Annotated[GulpPluginParameters, Body(description="anything needed by the bridge to perform the task on the target must be passed here (i.e. mapping, custom_parameters, ...)")],
        req_id: Annotated[str, Depends(APIDependencies.ensure_req_id_optional)] = None,
    ) -> JSONResponse:
        params = locals()
        params.pop("self")
        params["plugin_params"] = plugin_params.model_dump()
        ServerUtils.dump_params(params)

        try:
            bridge_token: str = None
            bridge: Plugin.GulpBridgeEntry
            async with GulpCollab.get_instance().session() as sess:
                # check if we can access operation id and if the bridge exists
                s: GulpUserSession
                s, _, _ = await GulpOperation.get_by_id_wrapper(sess, token, operation_id, permission=GulpUserPermission.INGEST)
                _, bridge, _ = await Plugin.GulpBridgeEntry.get_by_id_wrapper(sess, token, bridge_id, permission=GulpUserPermission.INGEST)
                user_id: str = s.user_id
                bridge_token = bridge.bridge_token

                # check if the task already exists and it is running(status=ongoing)
                params_str = json.dumps(plugin_params.model_dump(), sort_keys=True)
                bridge_task_id = muty.crypto.hash_sha1(f"{bridge_id}{operation_id}{params_str}")
                existing = await Plugin.GulpBridgeTaskEntry.get_by_id(sess, bridge_task_id, throw_if_not_found=False)
                if existing and existing.status == GulpRequestStatus.ONGOING.value:
                    raise ObjectAlreadyExists(f"bridge task already ongoing with id {bridge_task_id}")
            
                task: Plugin.GulpBridgeTaskEntry
                if not existing:
                    # create task
                    task = await Plugin.GulpBridgeTaskEntry.create_internal(
                        sess,
                        s.user.id,
                        name=f"bridge_task_{bridge_task_id}",
                        obj_id=bridge_task_id,
                        operation_id=operation_id,
                        bridge_id=bridge_id,
                        plugin_params=(plugin_params.model_dump() if plugin_params else {}),
                        status=None,
                    )
                else:
                    # use existing
                    task = existing

                # call bridge to start ingestion
                bridge_url = bridge.url.rstrip("/") + "/start_ingestion"
                headers = {"Authorization": f"Bearer {bridge_token}", "Content-Type": "application/json"}
                payload = {
                    "bridge_id": bridge_id,
                    "bridge_task_id": bridge_task_id,
                    "operation_id": operation_id,
                    "plugin_params": plugin_params.model_dump() if plugin_params else {},
                }

                async with aiohttp.ClientSession() as http_sess:
                    timeout = aiohttp.ClientTimeout(total=self._bridge_timeout_sec)
                    async with http_sess.post(bridge_url, headers=headers, json=payload, timeout=timeout) as r:
                        if r.status != 200:
                            # something wrong happened, report error and set task as failed
                            error_msg: str = await r.text()
                            MutyLogger.get_instance().error(f"bridge start_ingestion error: {r.status} {error_msg}")
                            await task.update(sess, user_id=user_id, status=GulpRequestStatus.FAILED.value, error=error_msg)
                            raise Exception(f"bridge start_ingestion error: {r.status}, {error_msg}")

                    # set task status to ongoing
                    await task.update(sess, user_id=user_id, status=GulpRequestStatus.ONGOING.value)
                return JSONResponse(JSendResponse.success(req_id=req_id, data={"bridge_task_id": bridge_task_id}))
        except Exception as ex:
            raise JSendException(req_id=req_id) from ex

    async def _call_stop_ingestion(self, sess: AsyncSession, user_id: str, bridge: "Plugin.GulpBridgeEntry", task: "Plugin.GulpBridgeTaskEntry") -> str:
        """internal method to call bridge to stop ingestion for a task"""
        bridge_url = bridge.url.rstrip("/") + "/stop_ingestion"
        headers = {"Authorization": f"Bearer {bridge.bridge_token}", "Content-Type": "application/json"}
        payload = {"bridge_id": bridge.id, "bridge_task_id": task.id}
        async with aiohttp.ClientSession() as session:
            timeout = aiohttp.ClientTimeout(total=self._bridge_timeout_sec)
            async with session.post(bridge_url, headers=headers, json=payload, timeout=timeout) as r:
                if r.status != 200:
                    # error occurred, raise
                    error_msg = await r.text()
                    MutyLogger.get_instance().error(f"bridge stop_ingestion error: {r.status} {error_msg}")
                    await task.update(sess, user_id=user_id, status=GulpRequestStatus.FAILED.value, error=error_msg)
                    raise Exception(f"bridge stop_ingestion error: {r.status}, {error_msg}")
        return task.id

    async def stop_ingestion_handler(
        self,
        token: Annotated[str, Depends(APIDependencies.param_token)],
        bridge_task_id: Annotated[str, Body(description="a running bridge ingestion task returned from create_start_ingestion")],
        req_id: Annotated[str, Depends(APIDependencies.ensure_req_id_optional)] = None,
    ) -> JSONResponse:
        params = locals()
        params.pop("self")
        ServerUtils.dump_params(params)

        try:
            bridge: Plugin.GulpBridgeEntry

            async with GulpCollab.get_instance().session() as sess:
                task: Plugin.GulpBridgeTaskEntry
                s, task, _ = await Plugin.GulpBridgeTaskEntry.get_by_id_wrapper(sess, token, bridge_task_id, permission=GulpUserPermission.INGEST)
                bridge = await Plugin.GulpBridgeEntry.get_by_id(sess, task.bridge_id)
                user_id: str = s.user_id

                # call bridge to stop ingestion
                await self._call_stop_ingestion(sess, user_id, bridge, task)

                # set task status as None (stopped)
                await task.update(sess, user_id=user_id, status=None, req_id=req_id)
                return JSONResponse(JSendResponse.success(req_id=req_id, data={"bridge_task_id": bridge_task_id}))
        except Exception as ex:
            raise JSendException(req_id=req_id) from ex

    async def delete_ingestion_handler(
        self,
        token: Annotated[str, Depends(APIDependencies.param_token)],
        bridge_task_id: Annotated[str, Query(description="a running bridge ingestion task returned from create_start_ingestion (will be stopped and deleted)")],
        req_id: Annotated[str, Depends(APIDependencies.ensure_req_id_optional)] = None,
    ) -> JSONResponse:
        params = locals()
        params.pop("self")
        ServerUtils.dump_params(params)
        try:
            bridge: Plugin.GulpBridgeEntry
            async with GulpCollab.get_instance().session() as sess:
                task: Plugin.GulpBridgeTaskEntry
                s, task, _ = await Plugin.GulpBridgeTaskEntry.get_by_id_wrapper(sess, token, bridge_task_id, permission=GulpUserPermission.INGEST)
                bridge = await Plugin.GulpBridgeEntry.get_by_id(sess, task.bridge_id)
                user_id: str = s.user_id

                # call bridge to stop ingestion first
                await self._call_stop_ingestion(sess, user_id, bridge, task)

                # then delete ingestion task on collab
                await task.delete(sess, user_id=user_id, req_id=req_id)
                return JSONResponse(JSendResponse.success(req_id=req_id, data={"bridge_task_id": bridge_task_id}))
        except Exception as ex:
            raise JSendException(req_id=req_id) from ex

    async def list_ingestion_tasks_handler(
        self,
        token: Annotated[str, Depends(APIDependencies.param_token)],
        flt: Annotated[Optional[GulpCollabFilter], Body(description="filter to apply (e.g. {'status': 'ongoing', 'bridge_id': 'abc123'})")] = None,
        req_id: Annotated[str, Depends(APIDependencies.ensure_req_id_optional)] = None,
    ) -> JSONResponse:
        params = locals()
        params.pop("self")
        params["flt"] = flt.model_dump() if flt else None
        ServerUtils.dump_params(params)

        try:
            d = await Plugin.GulpBridgeTaskEntry.get_by_filter_wrapper(token, flt or GulpCollabFilter(), permission=GulpUserPermission.INGEST)
            return JSONResponse(JSendResponse.success(req_id=req_id, data=d))
        except Exception as ex:
            raise JSendException(req_id=req_id) from ex

    async def list_bridges_handler(
        self,
        token: Annotated[str, Depends(APIDependencies.param_token)],
        flt: Annotated[Optional[GulpCollabFilter], Body(description="filter to apply (e.g. {'status': 'ready'})")] = None,
        req_id: Annotated[str, Depends(APIDependencies.ensure_req_id_optional)] = None,
    ) -> JSONResponse:
        params = locals()
        params.pop("self")
        params["flt"] = flt.model_dump() if flt else None

        ServerUtils.dump_params(params)

        try:
            d = await Plugin.GulpBridgeEntry.get_by_filter_wrapper(token, flt or GulpCollabFilter(), permission=GulpUserPermission.INGEST)
            return JSONResponse(JSendResponse.success(req_id=req_id, data=d))
        except Exception as ex:
            raise JSendException(req_id=req_id) from ex

    async def set_bridge_task_status_handler(
        self,
        token: Annotated[str, Depends(APIDependencies.param_token)],
        bridge_task_id: Annotated[str, Query(description="a running bridge ingestion task returned from create_start_ingestion")],
        status: Annotated[Literal["failed", "done", "ongoing", "canceled"], Body(description="one of the GulpRequestStatus values to set for the task")],
        error: Annotated[Optional[str], Body(description="error message, in case of failure")],
        req_id: Annotated[str, Depends(APIDependencies.ensure_req_id_optional)] = None,
    ) -> JSONResponse:
        params = locals()
        params.pop("self")
        ServerUtils.dump_params(params)

        try:
            async with GulpCollab.get_instance().session() as sess:
                task: Plugin.GulpBridgeTaskEntry
                s, task, _ = await Plugin.GulpBridgeTaskEntry.get_by_id_wrapper(sess, token, bridge_task_id, permission=GulpUserPermission.INGEST)
                await task.update(sess, user_id=s.user.id, status=status, error=error)

            return JSONResponse(JSendResponse.success(req_id=req_id, data={"bridge_task_id": bridge_task_id}))
        except Exception as ex:
            raise JSendException(req_id=req_id) from ex
