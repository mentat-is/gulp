from typing import Any, Optional

import muty.string
from elasticsearch import AsyncElasticsearch
from muty.log import MutyLogger
from muty.pydantic import autogenerate_model_example_by_class
from opensearchpy import AsyncOpenSearch
from pydantic import BaseModel, ConfigDict, Field
from sqlalchemy.ext.asyncio import AsyncSession

from gulp.api.opensearch.filters import QUERY_DEFAULT_FIELDS, GulpQueryFilter
from gulp.structs import GulpPluginParameters, GulpSortOrder


class GulpQuery(BaseModel):
    """
    A query
    """

    def __init__(
        self,
        q: Any,
        name: str = None,
        sigma_id: str = None,
        tags: list[str] = None,
    ):
        if name is None:
            # autogenerate name
            name = "query_%s" % (muty.string.generate_unique())
        if tags is None:
            tags = []

        super().__init__(
            name=name,
            q=q,
            sigma_id=sigma_id,
            tags=tags,
        )

    model_config = ConfigDict(
        json_schema_extra={
            "examples": [
                {
                    "name": "test",
                    "id": "test",
                    "q": {"query": {"match_all": {}}},
                    "tags": ["test"],
                }
            ]
        }
    )
    q: Any = Field(..., description="the query in the target DSL format.")
    name: Optional[str] = Field(
        None,
        description="the name/title of the query, autogenerated if not set.",
    )
    sigma_id: Optional[str] = Field(
        None, description="the id of the sigma rule, if this is a sigma query."
    )
    tags: Optional[list[str]] = Field([], description="query tags.")


class GulpQueryNoteParameters(BaseModel):
    """
    to automatically create notes on query matches
    """

    model_config = ConfigDict(
        json_schema_extra={
            "examples": [
                {
                    "create_notes": True,
                    "note_name": "test",
                    "note_tags": ["test"],
                    "note_color": None,
                    "note_glyph_id": None,
                    "note_private": False,
                }
            ]
        }
    )
    create_notes: bool = Field(
        False,
        description="if set, creates a note for every match (default for sigma queries and during external query ingestion)",
    )
    note_name: str = Field(
        None,
        description="the display name of the notes to create on match, defaults None (uses query name)",
    )
    note_tags: list[str] = Field(
        [],
        description='the tags of the notes to create on match, defaults to [] (["auto", sigma rule tags (for sigma queries))',
    )
    note_color: str = Field(
        None,
        description="the color of the notes to create on match, defaults to None (use notes default color)",
    )
    note_glyph_id: str = Field(
        None,
        description="id of the glyph of the notes to create on match, defaults to None (query group glyph if set, otherwise use notes default).",
    )


class GulpQueryExternalParameters(BaseModel):
    """
    parameters to be set for ingestion via `external` sources query.
    """

    model_config = ConfigDict(
        json_schema_extra={
            "examples": [
                {
                    "plugin": "test_plugin",
                    "uri": "http://localhost:8080",
                    "username": "user",
                    "password": "password",
                    "params": None,
                    "ingest_index": "target_index",
                    "operation_id": "operation_1",
                    "context_name": "context_1",
                    "source": "test_source",
                }
            ]
        },
        extra="allow",
    )
    plugin: Optional[str] = Field(
        None,
        description="the plugin to be used to query the external source.",
    )
    plugin_params: Optional[GulpPluginParameters] = Field(
        GulpPluginParameters(),
        description="custom plugin parameters to pass to the external plugin.",
    )
    uri: Optional[str] = Field(
        None, description="The URI to connect to the external service."
    )
    username: Optional[str] = Field(
        None, description="The username to connect to the external service."
    )
    password: Optional[str] = Field(
        None, description="The password to connect to the external service."
    )
    ingest_index: Optional[str] = Field(
        None, description="if set, ingest the results to this gulp index/datastream."
    )
    operation_id: Optional[str] = Field(
        None,
        description="""
if set, the operation id to associate with the ingestion.

- ignored if `ingest_index` is not set.
""",
    )
    context_name: Optional[str] = Field(
        None,
        description="""
if set, name of the context to associate with the ingestion.

- an id will be generated if not yet present.
- if not set, the plugin is responsible to generate a `context_id` and `source_id` for the ingestion.
- ignored if `ingest_index` is not set.
""",
    )


class GulpQueryParameters(BaseModel):
    """
    additional options for a query.

    when using with external queries, not all options are guaranteed to be implemented (it is the plugin responsibility to handle them)
    """

    model_config = ConfigDict(
        extra="allow",
        json_schema_extra={
            "examples": [
                {
                    "sort": {
                        "@timestamp": GulpSortOrder.ASC,
                        "_id": GulpSortOrder.ASC,
                        "event.sequence": GulpSortOrder.ASC,
                    },
                    "fields": ["@timestamp", "event.id"],
                    "limit": 1000,
                    "group": "test",
                    "name": "test",
                    "search_after": None,
                    "loop": True,
                    "note_parameters": autogenerate_model_example_by_class(
                        GulpQueryNoteParameters
                    ),
                    "external_parameters": autogenerate_model_example_by_class(
                        GulpQueryExternalParameters
                    ),
                }
            ]
        },
    )
    name: Optional[str] = Field(
        None,
        description="the name of the query: for sigma queries, this is automatically set to the sigma rule name/title.",
    )
    group: Optional[str] = Field(
        None,
        description="the query group, if any: if set, `QUERY_GROUP_MATCH` is sent on the websocket when there is at least a match for each query belonging to the same group.",
    )
    sort: Optional[dict[str, GulpSortOrder]] = Field(
        default=None,
        description="""
how to sort results, default=sort by ascending `@timestamp`. 

- for `external` queries, its the plugin responsibility to handle this.""",
    )
    fields: Optional[list[str] | str] = Field(
        default=None,
        description="""
the set of fields to include in the returned documents.

- for `external` queries, the plugin should ignore this and always return all fields
- default=`%s`, use `*` to return all fields.
"""
        % (QUERY_DEFAULT_FIELDS),
    )
    ensure_default_fields: Optional[bool] = Field(
        True,
        description="""
if set and `fields` is set, ensure the default fields (%s) are included in the returned documents (default=True).

- for `external` queries, its the plugin responsibility to handle this.""" % (QUERY_DEFAULT_FIELDS),
    )
    limit: Optional[int] = Field(
        1000,
        ge=1,
        le=10000,
        description="""
for pagination, the maximum number of documents to return **per chunk**, default=1000 (None=return up to 10000 documents per chunk).

- for `external` queries, its the plugin responsibility to handle this.""",
    )
    search_after: Optional[list[dict]] = Field(
        None,
        description="""
for pagination, this should be set to the `search_after` returned by the previous call.

- check [OpenSearch documentation](https://opensearch.org/docs/latest/search-plugins/searching-data/paginate/#the-search_after-parameter).
- ignored if `loop` is set.
- for `external` queries, its the plugin responsibility to handle this.
""",
    )
    loop: Optional[bool] = Field(
        True,
        description="""
if set, keep querying until all documents are returned (default=True, ignores `search_after`).

- for `external` queries, its the plugin responsibility to handle this.
""",
    )
    note_parameters: Optional[GulpQueryNoteParameters] = Field(
        GulpQueryNoteParameters(),
        description="controls how notes are created during queries.",
    )
    external_parameters: Optional[GulpQueryExternalParameters] = Field(
        GulpQueryExternalParameters(),
        description="external query specific parameters, including `plugin` and `GulpPluginParameters` used to perform the external query.",
    )

    def parse(self) -> dict:
        """
        Parse the additional options to a dictionary for the OpenSearch/Elasticsearch search api.

        Returns:
            dict: The parsed dictionary.
        """
        n = {}

        # sorting
        n["sort"] = []
        if not self.sort:
            # default sort
            sort = {
                "@timestamp": GulpSortOrder.ASC,
                "_id": GulpSortOrder.ASC,
                "event.sequence": GulpSortOrder.ASC,
            }

        else:
            # use provided
            sort = self.sort

        for k, v in sort.items():
            n["sort"].append({k: {"order": v}})
            if "_id" not in sort:
                # make sure _id is always sorted
                n["sort"].append({"_id": {"order": v}})
            if "event.sequence" not in sort:
                # make sure event.sequence is always sorted
                n["sort"].append({"event.sequence": {"order": v}})

        # fields to be returned
        if not self.fields:
            # default, if not set
            fields = QUERY_DEFAULT_FIELDS
        else:
            # use the given set
            fields = self.fields

        n["_source"] = None
        if fields != "*":
            # if "*", return all (so we do not set "_source"). either, only return these fields
            if self.ensure_default_fields:
                # ensure default fields are included
                for f in QUERY_DEFAULT_FIELDS:
                    if f not in fields:
                        fields.append(f)
            n["_source"] = fields

        # pagination: doc limit
        n["size"] = None
        if self.limit is not None:
            # use provided
            n["size"] = self.limit

        # pagination: start from
        if self.search_after:
            # next chunk from this point
            n["search_after"] = self.search_after
        else:
            n["search_after"] = None

        # MutyLogger.get_instance().debug("query options: %s" % (json.dumps(n, indent=2)))
        return n


class GulpQueryHelpers:
    """
    helpers to perform queries
    """

    @staticmethod
    def merge_queries(q1: dict, q2: dict) -> dict:
        """
        merge two queries into one.

        Args:
            q1 (dict): the first query
            q2 (dict): the second query

        Returns:
            dict: the merged query
        """
        # handle empty queries
        if not q1:
            return q2
        if not q2:
            return q1

        return {
            "query": {"bool": {"filter": [q1.get("query", q1), q2.get("query", q2)]}}
        }

    @staticmethod
    async def query_raw(
        sess: AsyncSession,
        user_id: str,
        req_id: str,
        ws_id: str,
        q: dict,
        index: str,
        flt: GulpQueryFilter = None,
        q_options: GulpQueryParameters = None,
        el: AsyncElasticsearch | AsyncOpenSearch = None,
        callback: callable = None,
        callback_args: dict = None,
        callback_chunk: callable = None,
        callback_chunk_args: dict = None,
    ) -> tuple[int, int]:
        """
        Perform a raw opensearch/elasticsearch DSL query using "search" API, streaming GulpDocumentChunk results to the websocket.

        Args:
            sess(AsyncSession): collab database session
            user_id(str): the user id of the requestor
            req_id(str): the request id
            ws_id(str): the websocket id
            q(dict): the dsl query to be used in OpenSearch/Elasticsearch DSL language, must have "query" set.
            index(str): the opensearch/elasticsearch index/datastream to target
            flt(GulpQueryFilter, optional): if set, the filter to merge with the query (to restrict the search)
            q_options(GulpQueryParameters, optional): additional options to use
            el (AsyncElasticSearch|AsyncOpenSearch, optional): an EXTERNAL ElasticSearch/OpenSearch client to use instead of the default internal gulp's OpenSearch. Defaults to None.
            callback (callable, optional): the callback to call for each document found. Defaults to None.
                the callback must be defined as:
                async def callback(doc: dict, idx: int, **kwargs) -> None
            callback_args (dict, optional): further arguments to pass to the callback. Defaults to None.
            callback_chunk (callable, optional): the callback to call for each chunk of documents found. Defaults to None.
                the callback must be defined as:
                async def callback_chunk(docs: list[dict], **kwargs) -> None
            callback_chunk_args (dict, optional): further arguments to pass to the callback_chunk. Defaults to None.
        Returns:
            tuple[int, int]: the number of documents processed and the total number of documents found
        Raises:
            Exception: if an error occurs during the query
        """
        MutyLogger.get_instance().debug(
            "GulpQueryHelpers.query_raw: q=%s, index=%s, flt=%s, q_options=%s"
            % (q, index, flt, q_options)
        )
        if not q_options:
            q_options = GulpQueryParameters()

        if "query" not in q.keys():
            raise ValueError("q must have 'query' set")

        if flt and not flt.is_empty():
            # merge with filter
            q = flt.merge_to_opensearch_dsl(q)

        from gulp.api.opensearch_api import GulpOpenSearch

        processed, total = await GulpOpenSearch.get_instance().search_dsl(
            sess=sess,
            index=index,
            q=q,
            req_id=req_id,
            ws_id=ws_id,
            user_id=user_id,
            q_options=q_options,
            el=el,
            callback=callback,
            callback_args=callback_args or {},
            callback_chunk=callback_chunk,
            callback_chunk_args=callback_chunk_args or {},
        )
        return processed, total

    @staticmethod
    async def query_single(
        index: str,
        doc_id: str,
        el: AsyncElasticsearch | AsyncOpenSearch = None,
    ) -> dict:
        """
        Perform a single document query using the given document id on gulp's opensearch/elasticsearch, and return the document as a GulpDocument dictionary.

        Args:
            req_id (str): the request id
            index (str): the opensearch/elasticsearch index/datastream to target
            doc_id (str): the document id to query
            el (AsyncElasticSearch|AsyncOpenSearch, optional): an EXTERNAL ElasticSearch/OpenSearch client to use instead of the default internal gulp's OpenSearch. Defaults to None.

        Returns:
            dict: the document as a GulpDocument dictionary

        Raises:
            ObjectNotFound: if the document is not found.
        """
        from gulp.api.opensearch_api import GulpOpenSearch

        return await GulpOpenSearch.get_instance().query_single_document(
            index, doc_id, el=el
        )
