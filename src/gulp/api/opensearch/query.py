"""
This module provides functionality for querying OpenSearch/Elasticsearch within the Gulp API.

It includes classes and utilities for creating and executing queries against OpenSearch/Elasticsearch
indices, with support for various query parameters, filtering, pagination, and note creation.

The main components are:

- GulpQuery: A model for representing queries with various metadata
- GulpQueryNoteParameters: Parameters for creating notes on query matches
- GulpQueryParameters: Additional options for configuring query execution
- GulpQueryHelpers: Utility methods for executing queries and manipulating query objects

This module supports both OpenSearch and Elasticsearch backends through their respective
async client interfaces.

"""

import orjson
from typing import Any, Optional

import muty.string
from elasticsearch import AsyncElasticsearch
from muty.log import MutyLogger
from muty.pydantic import autogenerate_model_example_by_class
from opensearchpy import AsyncOpenSearch
from pydantic import BaseModel, ConfigDict, Field
from sqlalchemy.ext.asyncio import AsyncSession

from gulp.api.opensearch.filters import QUERY_DEFAULT_FIELDS, GulpQueryFilter
from gulp.structs import GulpSortOrder


class GulpQuery(BaseModel):
    """
    A query
    """

    def __init__(
        self,
        q: Any,
        name: str = None,
        sigma_yml: str = None,
        sigma_id: str = None,
        tags: list[str] = None,
    ):
        if name is None:
            # autogenerate name
            name = "query_%s" % (muty.string.generate_unique())
        if tags is None:
            tags = []

        super().__init__(
            name=name,
            sigma_yml=sigma_yml,
            q=q,
            sigma_id=sigma_id,
            tags=tags,
        )

    model_config = ConfigDict(
        json_schema_extra={
            "examples": [
                {
                    "name": "test",
                    "id": "test",
                    "q": {"query": {"match_all": {}}},
                    "tags": ["test"],
                }
            ]
        }
    )
    q: Any = Field(..., description="the query in the target DSL format.")
    name: Optional[str] = Field(
        None, description="the name/title of the query, autogenerated if not set."
    )
    sigma_yml: Optional[str] = Field(
        None, description="if this is a sigma rule, the query in YAML format."
    )
    sigma_id: Optional[str] = Field(
        None, description="the id of the sigma rule, if this is a sigma query."
    )
    tags: Optional[list[str]] = Field([], description="query tags.")


class GulpQueryNoteParameters(BaseModel):
    """
    to automatically create notes on query matches
    """

    model_config = ConfigDict(
        json_schema_extra={
            "examples": [
                {
                    "create_notes": True,
                    "note_name": "test",
                    "note_tags": ["test"],
                    "note_color": None,
                    "note_glyph_id": None,
                    "note_private": False,
                }
            ]
        }
    )
    create_notes: bool = Field(
        None,
        description="if True, creates a note for every match (default for sigma queries and during external query ingestion, unless explicitly set to False)",
    )
    note_name: str = Field(
        None,
        description="the display name of the notes to create on match, defaults None (uses query name)",
    )
    note_tags: list[str] = Field(
        [],
        description='the tags of the notes to create on match, defaults to [] (["auto", sigma rule tags (for sigma queries))',
    )
    note_color: str = Field(
        None,
        description="the color of the notes to create on match, defaults to None (use notes default color)",
    )
    note_glyph_id: str = Field(
        None,
        description="id of the glyph of the notes to create on match, defaults to None (query group glyph if set, otherwise use notes default).",
    )


class GulpQueryParameters(BaseModel):
    """
    additional options for a query.

    NOTE: when using with external queries, not all options are guaranteed to be implemented (it is the plugin responsibility to handle them)
    """

    model_config = ConfigDict(
        extra="allow",
        json_schema_extra={
            "examples": [
                {
                    "sort": {
                        "@timestamp": GulpSortOrder.ASC,
                        "_doc": GulpSortOrder.ASC,
                        "event.sequence": GulpSortOrder.ASC,
                    },
                    "fields": ["@timestamp", "event.id"],
                    "limit": 1000,
                    "total_limit": 0,
                    "group": "test",
                    "name": "test",
                    "preview_mode": False,
                    "search_after": None,
                    "loop": True,
                    "note_parameters": autogenerate_model_example_by_class(
                        GulpQueryNoteParameters
                    ),
                }
            ]
        },
    )
    name: Optional[str] = Field(
        None,
        description="the name of the query: for sigma queries, this is automatically set to the sigma rule name/title.",
    )
    group: Optional[str] = Field(
        None,
        description="the query group, if any: if set, `QUERY_GROUP_MATCH` is sent on the websocket when there is at least a match for each query belonging to the same group.",
    )
    sort: Optional[dict[str, GulpSortOrder]] = Field(
        default=None,
        description="""
how to sort results, default=sort by ascending `@timestamp`.

- for `external` queries, its the plugin responsibility to handle this.""",
    )
    fields: Optional[list[str] | str] = Field(
        default=None,
        description="""
the set of fields to include in the returned documents.

- for `external` queries, the plugin should ignore this and always return all fields
- default=`%s`, use `*` to return all fields.
"""
        % (QUERY_DEFAULT_FIELDS),
    )
    ensure_default_fields: Optional[bool] = Field(
        True,
        description="""
if set and `fields` is set, ensure the default fields (%s) are included in the returned documents (default=True).

- for `external` queries, its the plugin responsibility to handle this."""
        % (QUERY_DEFAULT_FIELDS),
    )
    limit: Optional[int] = Field(
        1000,
        ge=1,
        le=10000,
        description="""
for pagination, the maximum number of documents to return **per chunk**, default=1000 (None=return up to 10000 documents per chunk).

- for `external` queries, its the plugin responsibility to handle this.""",
    )
    total_limit: Optional[int] = Field(
        0,
        description="""
The maximum number of documents to return in total, default=0 (no limit).

NOTE: as documents are returned in chunk of `limit` size, total is intended as a multiple of it. default=0 (no limit).
""",
    )
    search_after: Optional[list[dict]] = Field(
        None,
        description="""
for pagination, this should be set to the `search_after` returned by the previous call.

- check [OpenSearch documentation](https://opensearch.org/docs/latest/search-plugins/searching-data/paginate/#the-search_after-parameter).
- ignored if `loop` is set.
- for `external` queries, its the plugin responsibility to handle this.
""",
    )
    loop: Optional[bool] = Field(
        True,
        description="""
if set, keep querying until all documents are returned (default=True, ignores `search_after`).

- for `external` queries, its the plugin responsibility to handle this.
""",
    )
    note_parameters: Optional[GulpQueryNoteParameters] = Field(
        GulpQueryNoteParameters(),
        description="controls how notes are created during queries.",
    )
    preview_mode: Optional[bool] = Field(
        False,
        description="""
if set, the query is **synchronous** and returns the preview chunk of documents, without streaming data on the websocket nor counting data in the stats.
""",
    )

    def parse(self) -> dict:
        """
        Parse the additional options to a dictionary for the OpenSearch/Elasticsearch search api.

        Returns:
            dict: The parsed dictionary.
        """
        n = {}

        # sorting
        n["sort"] = []
        if not self.sort:
            # default sort
            sort = {
                "@timestamp": GulpSortOrder.ASC,
                # read the NOTE below...
                "_doc": GulpSortOrder.ASC,
                "event.sequence": GulpSortOrder.ASC,
            }

        else:
            # use provided
            sort = self.sort

        for k, v in sort.items():
            n["sort"].append({k: {"order": v}})
            # NOTE: test with VERY VERY large datasets (5M+), and consider to remove "_doc" here this since it may not be needed after all.... event.sequence should be enough.
            if "_doc" not in sort:
                # make sure document order is always sorted, use _doc instead of _id for less overhead (CircuitBreakingException error from opensearch)
                n["sort"].append({"_doc": {"order": v}})
            if "event.sequence" not in sort:
                # make sure event.sequence is always sorted
                n["sort"].append({"event.sequence": {"order": v}})

        # fields to be returned
        if not self.fields:
            # default, if not set
            fields = QUERY_DEFAULT_FIELDS
        else:
            # use the given set
            fields = self.fields

        n["_source"] = None
        if fields != "*":
            # if "*", return all (so we do not set "_source"). either, only return these fields
            if self.ensure_default_fields:
                # ensure default fields are included
                for f in QUERY_DEFAULT_FIELDS:
                    if f not in fields:
                        fields.append(f)
            n["_source"] = fields

        # pagination: doc limit
        n["size"] = None
        if self.limit is not None:
            # use provided
            n["size"] = self.limit

        # pagination: start from
        if self.search_after:
            # next chunk from this point
            n["search_after"] = self.search_after
        else:
            n["search_after"] = None

        # MutyLogger.get_instance().debug("query options: %s" % (orjson.dumps(n, option=orjson.OPT_INDENT_2)))
        return n


class GulpQueryHelpers:
    """
    helpers to perform queries
    """

    @staticmethod
    def merge_queries(q1: dict, q2: dict) -> dict:
        """
        merge two queries into one.

        Args:
            q1 (dict): the first query
            q2 (dict): the second query

        Returns:
            dict: the merged query
        """
        # handle empty queries
        if not q1:
            return q2
        if not q2:
            return q1

        return {
            "query": {"bool": {"filter": [q1.get("query", q1), q2.get("query", q2)]}}
        }

    @staticmethod
    async def query_raw(
        sess: AsyncSession,
        user_id: str,
        req_id: str,
        ws_id: str,
        q: dict,
        index: str,
        flt: GulpQueryFilter = None,
        q_options: GulpQueryParameters = None,
        el: AsyncElasticsearch | AsyncOpenSearch = None,
        callback: callable = None,
        callback_args: dict = None,
        callback_chunk: callable = None,
        callback_chunk_args: dict = None,
        source_q: str = None,
    ) -> tuple[int, int, str]:
        """
        Perform a raw opensearch/elasticsearch DSL query using "search" API, streaming GulpDocumentChunk results to the websocket.

        Args:
            sess(AsyncSession): collab database session
            user_id(str): the user id of the requestor
            req_id(str): the request id
            ws_id(str): the websocket id
            q(dict): the dsl query to be used in OpenSearch/Elasticsearch DSL language, must have "query" set.
            index(str): the opensearch/elasticsearch index/datastream to target
            flt(GulpQueryFilter, optional): if set, the filter to merge with the query (to restrict the search)
            q_options(GulpQueryParameters, optional): additional options to use
            el (AsyncElasticSearch|AsyncOpenSearch, optional): an EXTERNAL ElasticSearch/OpenSearch client to use instead of the default internal gulp's OpenSearch. Defaults to None.
            callback (callable, optional): the callback to call for each document found. Defaults to None.
                the callback must be defined as:
                async def callback(doc: dict, idx: int, **kwargs) -> None
            callback_args (dict, optional): further arguments to pass to the callback. Defaults to None.
            callback_chunk (callable, optional): the callback to call for each chunk of documents found. Defaults to None.
                the callback must be defined as:
                async def callback_chunk(docs: list[dict], **kwargs) -> None
            callback_chunk_args (dict, optional): further arguments to pass to the callback_chunk. Defaults to None.
            source_q (str, optional): the source query (i.e. the original query before any transformation). Defaults to None.
        Returns:
            tuple[int, int, str]: the number of documents processed, the total number of hits (they should be the same if all documents are processed), the query name.
        Raises:
            Exception: if an error occurs during the query
        """
        if not q_options:
            q_options = GulpQueryParameters()

        if "query" not in q.keys():
            raise ValueError("q must have 'query' set")

        if flt and not flt.is_empty():
            # merge with filter
            q = flt.merge_to_opensearch_dsl(q)

        MutyLogger.get_instance().debug(
            "GulpQueryHelpers.query_raw: index=%s, q=%s"
            % (index, orjson.dumps(q, option=orjson.OPT_INDENT_2))
        )

        from gulp.api.opensearch_api import GulpOpenSearch

        processed, total = await GulpOpenSearch.get_instance().search_dsl(
            sess=sess,
            index=index,
            q=q,
            req_id=req_id,
            ws_id=ws_id,
            user_id=user_id,
            q_options=q_options,
            el=el,
            callback=callback,
            callback_args=callback_args or {},
            callback_chunk=callback_chunk,
            callback_chunk_args=callback_chunk_args or {},
            source_q=source_q,
        )
        return processed, total, q_options.name

    @staticmethod
    async def query_single(
        index: str,
        doc_id: str,
        el: AsyncElasticsearch | AsyncOpenSearch = None,
    ) -> dict:
        """
        Perform a single document query using the given document id on gulp's opensearch/elasticsearch, and return the document as a GulpDocument dictionary.

        Args:
            req_id (str): the request id
            index (str): the opensearch/elasticsearch index/datastream to target
            doc_id (str): the document id to query
            el (AsyncElasticSearch|AsyncOpenSearch, optional): an EXTERNAL ElasticSearch/OpenSearch client to use instead of the default internal gulp's OpenSearch. Defaults to None.

        Returns:
            dict: the document as a GulpDocument dictionary

        Raises:
            ObjectNotFound: if the document is not found.
        """
        from gulp.api.opensearch_api import GulpOpenSearch

        return await GulpOpenSearch.get_instance().query_single_document(
            index, doc_id, el=el
        )
