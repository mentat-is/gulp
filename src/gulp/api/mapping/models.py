"""
Mapping models for Gulp, which facilitates transforming log sources into standardized documents.

This module defines the data structures used to map source data fields to ECS (Elastic Common Schema) fields.
The mapping system supports transformations, type conversion, and the creation of multiple output documents
from a single input event.

Key components:
- GulpMappingField: Configuration for individual field mappings with transformation options
- GulpMapping: Full mapping definition for translating a log source to Gulp documents
- GulpMappingFileMetadata: Metadata for mapping files, including plugin associations
- GulpMappingFile: Container for multiple mappings that can be loaded from JSON
"""

from typing import Literal, Optional

from muty.pydantic import autogenerate_model_example_by_class
from pydantic import BaseModel, ConfigDict, Field


class GulpMappingField(BaseModel):
    """
    defines how to map a single field, including field-specific options.
    """

    model_config = ConfigDict(
        extra="allow",
        json_schema_extra={
            "examples": [
                {
                    "ecs": ["test.mapped"],
                    "extra_doc_with_event_code": "1234",
                    "is_timestamp_chrome": False,
                }
            ]
        },
    )

    ecs: Optional[list[str] | str] = Field(
        None,
        description="one or more ECS field names to map the source field to in the resulting document.",
        min_length=1,
    )
    extra_doc_with_event_code: Optional[str] = Field(
        None,
        description="""
if this is set, `ecs` is ignored and the creation of an extra document is triggered with the given `event.code` and `@timestamp` set to this field value.

in this setting, the mapping file should:

- map a **single** field directly as `@timestamp` (to indicate the *main* document)
- set `mapping.event_code` to the *main* event code
- add additional `extra_doc_with_event_code` fields to create further documents with their own event code.

check `mftecmd_csv.json` for an example of this setting.
""",
    )
    is_timestamp_chrome: Optional[bool] = Field(
        False,
        description="if set, the corresponding value is a `webkit timestamp` (from 1601) and will be converted to nanoseconds from the unix epoch.",
    )
    is_context: Optional[bool] = Field(
        False,
        description="""
if set, the corresponding value is the 'name' of a GulpContext, which is created (if not existent) and its `id` set as `gulp.context_id` in the resulting document."

if this is set, another field in this record's mapping must be set to `is_source` to indicate the source.

this also overrides 'context' passed during ingestion, if any.
""",
    )
    is_source: Optional[bool] = Field(
        False,
        description="""
if set, the corresponding value is the 'name' of a GulpSource, which is created (if not existent) and its `id` set as `gulp.source_id` in the resulting document.

if this is set, another field in this record's mapping must be set to `is_context` to indicate the context of the source.

this also overrides 'source' passed during ingestion, if any.
""",
    )
    multiplier: Optional[float] = Field(
        None,
        description="if set and > 1, the corresponding value is multiplied by this value.",
    )
    force_type: Optional[Literal["str", "int", "float"]] = Field(
        None,
        description="if set, the corresponding value is forced to this type before ingestion.",
    )

    extract: Optional[str] = Field(
        None,
        description="""
if set, the source is expected to be a dictionary or a list and the given key is extracted.
i.e. if the source field is `{"key": { "k": [1,2,3] } }`, and `extract` is set to `"key.k[1]"`, the resulting value will be `2`.
""",
    )


class GulpMapping(BaseModel):
    """
    defines a logsource -> gulp document mapping
    """

    model_config = ConfigDict(
        extra="allow",
        json_schema_extra={
            "examples": [
                {
                    "fields": {"field1": {"ecs": ["test.mapped"]}},
                    "description": "test description.",
                    "agent_type": "win_evtx",
                    "event_code": "1234",
                    "allow_prefixed": False,
                }
            ]
        },
    )

    fields: Optional[dict[str, GulpMappingField]] = Field(
        {},
        description="field mappings { raw_field: { GulpMappingField } } to translate a logsource to gulp document.",
    )
    description: Optional[str] = Field(
        None,
        description="if set, mapping's description.",
    )
    agent_type: Optional[str] = Field(
        None,
        description='if set, all documents generated by this mapping have "agent.type" set to this value. either, the plugin is responsible for setting this.',
    )

    event_code: Optional[str] = Field(
        None,
        description='if set, all documents generated by this mapping have "event.code" set to this value (and "gulp.event_code" to the corresponding numeric value). either, the plugin is responsible for setting this.',
    )
    exclude: Optional[list[str]] = Field(
        None,
        description="if set, these fields are ignored and not included in the generated document/s.",
    )
    include: Optional[list[str]] = Field(
        None,
        description="if set, only these fields are processed and included in the generated document/s.",
    )

    # TODO: consider if this is needed or we can just deprecate/remove this.... it is used only by the win_evtx plugin and probably it is not needed even there.
    allow_prefixed: Optional[bool] = Field(
        False,
        description="""
if set, the source field can be prefixed and only last part after "_" is used to match the `ecs` mapping.
i.e. if the source field is "this_is_a_sourcekey", only "sourcekey" is considered.

""",
    )


class GulpMappingFileMetadata(BaseModel):
    """
    metadata for a mapping file.
    """

    model_config = ConfigDict(
        extra="allow", json_schema_extra={"examples": [{"plugin": ["win_evtx", "csv"]}]}
    )

    plugin: list[str] = Field(
        ...,
        description="one or more plugin names that this mapping file is associated with.",
    )


class GulpSigmaMapping(BaseModel):
    """
    defines a logsource -> gulp document mapping
    """

    model_config = ConfigDict(
        extra="allow",
        json_schema_extra={
            "examples": [
                {
                    "fields": {"field1": {"ecs": ["test.mapped"]}},
                    "description": "test description.",
                    "agent_type": "win_evtx",
                    "event_code": "1234",
                    "allow_prefixed": False,
                }
            ]
        },
    )

    service_name: str = Field(
        ...,
        description="`logsource.service` in the sigma rule.",
        examples=["windefend"],
    )
    service_field: str = Field(
        ...,
        description="field name corresponding to `service_name` in the documents.",
        examples=["winlog.channel"],
    )
    service_values: list[str] = Field(
        ...,
        description="list of (substring) values for the `service_name` field.",
        examples=[["Microsoft-Windows-Windows Defender"]],
    )


class GulpMappingFile(BaseModel):
    """
    a mapping file, containing one or more GulpMapping objects.
    """

    model_config = ConfigDict(
        extra="allow",
        json_schema_extra={
            "examples": [
                {
                    "mappings": autogenerate_model_example_by_class(GulpMapping),
                    "metadata": autogenerate_model_example_by_class(
                        GulpMappingFileMetadata
                    ),
                }
            ]
        },
    )

    mappings: dict[str, GulpMapping] = Field(
        ...,
        description="defined mappings for this mapping file, key is the `mapping_id`",
        min_length=1,
    )
    sigma_mappings: Optional[GulpSigmaMapping] = Field(
        None,
        description="if set, rules to map `lgosource` for sigma rules referring to this mapping.",
    )
    metadata: Optional[GulpMappingFileMetadata] = Field(
        ...,
        description="metadata for the mapping file.",
    )
